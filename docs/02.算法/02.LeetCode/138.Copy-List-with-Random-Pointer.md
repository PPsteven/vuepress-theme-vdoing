---
title: 【LeetCode】复制带随机指针的链表
date: 2020-08-07 15:53:00
tags: 
  - LeetCode
categories: 
  - LeetCode
keywords: null
description: null
top_img: https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20201014134505.png
comments: false
cover: null
toc: null
toc_number: null
copyright: null
permalink: /pages/980b1b/
---

## 题目描述

> [Leetcode 地址](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)
>
> [剑指 Offer 地址](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

## 类别

- 链表
- 哈希表
- dfs/bfs

## 解题思路

### 解法一【哈希表】

- 使用哈希表，将旧的地址与新的地址关联起来

  > 注意，这里的新的表，next 和 random 都没有创建好的就是，就存入了哈希表
  >
  > 利用的是 Python 哈希表存入的是引用（地址）的原理

### 代码

```python
class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        def copy(node):
            if not node:return node
            if not node in visited:
                visited[node] = Node(node.val)
            return visited[node]
        
        if not head: return head 
        old = head 
        new = Node(old.val)
        visited = {}
        visited[old] = new 

        while old:
            new.next = copy(old.next)
            new.random = copy(old.random)
            old = old.next
            new = new.next 
        return visited[head]
```



### 解法二

- DFS

<img src="https://cdn.jsdelivr.net/gh/PPsteven/pictures/img/20200714175143.png" style="zoom:50%;" />

### 代码

```python
class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        def dfs(node):
            if not node: 
                return node 
            if node in visited:
                return visited[node]
            new_node = Node(node.val)
            visited[node] = new_node  # 这句一定要在 递归语句之前，不然会存在反复创建的问题
            new_node.next = dfs(node.next)
            new_node.random = dfs(node.random)
            return new_node
        visited = {}
        return dfs(head)
```



### 解法三

- BFS

### 代码

```python
class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        def bfs(node):
            if not node: return node 
            new_node = Node(node.val)
            visited[node] = new_node
            queue = collections.deque()
            queue.append(node)
            while queue:
                temp = queue.pop()
                if temp.next and not temp.next in visited:
                    visited[temp.next] = Node(temp.next.val)
                    queue.append(temp.next)
                if temp.random and not temp.random in visited:
                    visited[temp.random] = Node(temp.random.val)
                    queue.append(temp.random)
                visited[temp].next = visited.get(temp.next)
                visited[temp].random = visited.get(temp.random)
            return visited[node]
        visited = {}
        return bfs(head)
```

